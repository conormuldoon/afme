// Copyright:   Copyright (c) 1996-2006 The Agent Factory Working Group. All rights reserved.
// Licence:     This file is free software; you can redistribute it and/or modify
//              it under the terms of the GNU Lesser General Public License as published by
//              the Free Software Foundation; either version 2.1, or (at your option)
//              any later version.
//
//              This file is distributed in the hope that it will be useful,
//              but WITHOUT ANY WARRANTY; without even the implied warranty of
//              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//              GNU Lesser General Public License for more details.
//
//              You should have received a copy of the GNU Lesser General Public License
//              along with Agent Factory Micro Edition; see the file COPYING.  If not, write to
//              the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
//              Boston, MA 02111-1307, USA.
//
//				Author: Conor Muldoon

$=/*  =$name$=AgentPlatform.java  */

// Generated by the Agent Factory Micro Edition (AFME) compiler.

package =$ pack $=;
import com.agentfactory.cldc.logic.FOS;
import javax.microedition.rms.RecordStore;
import com.agentfactory.cldc.logic.RoleLibrary;
import com.agentfactory.cldc.logic.RoleTemplate;
import com.agentfactory.cldc.logic.BelSeq;
import java.util.Hashtable;
import com.agentfactory.cldc.AgentName;

import javax.microedition.lcdui.Display;
import javax.microedition.lcdui.Displayable;

import com.agentfactory.cldc.UserInterface;
import com.agentfactory.cldc.BasicRunnable;
import com.agentfactory.cldc.scheduler.AgentRunnable;

import com.agentfactory.cldc.PerceptionManager;
import com.agentfactory.cldc.AffectManager;
import com.agentfactory.cldc.Perceptor;
import com.agentfactory.cldc.scheduler.Scheduler;
import com.agentfactory.cldc.logic.TerImplication;
import com.agentfactory.cldc.logic.Agent; 

import javax.microedition.rms.RecordStoreException;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import com.agentfactory.cldc.Platform;
import java.io.IOException;

import com.agentfactory.cldc.mts.IDSet;
import com.agentfactory.cldc.mts.AID;
import com.agentfactory.cldc.migration.MigrationPlatform;

import com.agentfactory.cldc.ActuatorFactory;
import com.agentfactory.cldc.PerceptorFactory;
import com.agentfactory.cldc.logic.MalformedLogicException;
import com.agentfactory.cldc.Module;
import com.agentfactory.cldc.Service;
import com.agentfactory.cldc.GUIFactory;
import com.agentfactory.cldc.ModuleFactory;
import com.agentfactory.cldc.Actuator;


import java.io.DataInput;
import java.util.Enumeration;



public class =$ name $=AgentPlatform implements MigrationPlatform,Platform{
    
    
    
    Scheduler scheduler;
    UserInterface inter;
    Hashtable services;
    
    =$name$=let let;
    String[]storeData,ids;
    Hashtable agents;

    public =$ name $=AgentPlatform(=$name$=let let) {
    
    	=$  agents{ $=AgentRunnable =$ agtname $=;
    	AgentName =$ agtname $=Name;=$ } $=
    	
        this.let=let;
        storeData=null;
        
        RecordStore rs=null;
        
        scheduler=new Scheduler(=$ numt $=);
        
        try{
            rs=RecordStore.openRecordStore("=$ name $=NameStore", true);
            int nextID=rs.getNextRecordID();
            storeData=new String[nextID-1];
            
            for( int id = nextID;id-->1; ){
                storeData[id-1]=new String(rs.getRecord(id)).trim();
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            try{
                rs.closeRecordStore();
            }catch(Exception e){
                e.printStackTrace();
            }
            
        }
        
          try{
            rs=RecordStore.openRecordStore("=$ name $=IDS", true);
            int nextID=rs.getNextRecordID();
            ids=new String[nextID-1];
            
            for( int id = nextID;id-->1; ){
                ids[id-1]=new String(rs.getRecord(id)).trim();
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            try{
                rs.closeRecordStore();
            }catch(Exception e){
                e.printStackTrace();
            }
            
        }
        
        services = new Hashtable();   
        agents=new Hashtable();

       
       
       =$ agents{ 
       agtname $=Name=createName("=$ agtname $=");
       =$ agtname $===$ namerole $=(=$ agtname $=Name,=$ resources $=);
       =$ agtname $=Name.addToTable(agents,=$agtname$=); =$ } 
       $=
       

       =$  bels{
       believer $=.addFOSBelief(FOS.createFOS("=$ bel $="));
       =$ } $=
       
       =$  starters{
       agtname$=.start();=$ } $=
       
       String[]stringNames=new String[=$ numagts $=];
       =$ agents{
       agtname$=Name.addName(stringNames,=$lcount$=);
       =$ } $=

        final AgentName agentName[]=new AgentName[=$numagts$=];
        =$  agents{
        $=agentName[=$lcount$=]==$agtname$=Name;
        =$ } $=
        
       
        //Service service;
        String[] args;
        =$
         services{
    $=
    	args=new String[=$numargs$=];=$
  	args{
        		$=
        args[=$lcount$=]="=$arg$=";=$
        	}
$=
		new =$classname$=(args,agentName,scheduler,this).register(services);
        =$ }
         
         $=
        
        =$gui{ 
        classname$= interService = new =$ classname $=(args,agentName,let,null);
        interService.register(services);
        inter=interService;
        =$}$=
     	
        =$  agents{
        	$=scheduler.schedule(=$agtname$=Name,=$agtname$=,=$responsetime$=);
        =$ } $=

        
    }
    
    public AgentName createName(String agentName){
        if(storeData!=null)for(int i=storeData.length;i-->0;){
            String smpNm=storeData[i].substring(0,storeData[i].indexOf(AgentName.DELIM));
            if(smpNm.equals(agentName))return new AgentName(storeData[i],"=$ name $=");
        }
        return new AgentName(agentName,"=$ name $=");
    }
	
	// Start the Scheduler
    public void start(){
        scheduler.start();
    }
    
    /* Pause the Scheduler. 
       Used for asynchronous events, such as received phone calls. */
    public void pause(){
        scheduler.pause();
    }
    
    // Terminate the Scheduler
    public void destroy(){
        scheduler.destroy();
        java.util.Enumeration en=services.elements();
        while(en.hasMoreElements()){
        	((com.agentfactory.cldc.Service)en.nextElement()).destroy();
        }
    }
    

    public void display(){
       
   }

    
    public void displayApp(){
        if(inter!=null)inter.display();
    }
    
    =$  
    
    
    designs{$=private BasicRunnable =$namerole$=(AgentName name,int res){
        
        Perceptor[]perceptor=new Perceptor[=$ numper $=];
        Hashtable actuator=new Hashtable();
        RoleLibrary roleLib=new RoleLibrary();
        BelSeq[] arr=null;
        
        boolean[] bool=null;
        =$  roles{
            $=TerImplication[]rule=new TerImplication[=$ numrules $=];
        =$  rules{$=
        		arr=new BelSeq[=$belNum$=];
        		bool=new boolean[=$belNum$=];
        		=$
        		depends{$=
        			arr[=$lcount$=]==$label$=;
        			bool[=$lcount$=]==$boolval$=;
        		=$
        		}
            	$=rule[=$lcount$=]=new TerImplication("=$rr$=",new BelSeq("=$rl$=",arr,bool));
        =$ } $=
        FOS[]trigger=new FOS[=$numtriggers$=];
        =$  triggers{
        	$=trigger[=$lcount$=]=FOS.createFOS("=$trig$=");
        =$ } $=
        FOS id=FOS.createFOS("=$id$=");
        roleLib.add(id,new RoleTemplate(rule,id,trigger));
        =$ } $=

        Hashtable modules=new Hashtable();
        
         =$ modules{
         	$=new =$ classname $=(name).register(modules);
         =$ } $=
        
        =$ intermod{ classname $= interMod=new =$ classname $=(name,let,null,scheduler);
        interMod.register(modules);
        inter=interMod;
        =$ } $=
        
        // To do: Create Helper Classes for parsing user input for hand written agents
        // For compiler generated classes all parsing should be performed by the compiler
        // create arrays of strings for beliefs etc.
        
		=$ sequences{ $=
        arr=new BelSeq[=$belNum$=];
        bool=new boolean[=$belNum$=];
        =$ depends{$=
        arr[=$lcount$=]==$label$=;
        bool[=$lcount$=]==$boolval$=;
        =$}
        $=BelSeq =$ label $==new BelSeq("=$rl$=",arr,bool);
        =$ } $=
        
        
        
        TerImplication[]mentalState=new TerImplication[=$ numrules $=];
        =$  rules{$=arr=new BelSeq[=$belNum$=];
        bool=new boolean[=$belNum$=];
        =$depends{$=
        arr[=$lcount$=]==$label$=;
        bool[=$lcount$=]==$boolval$=;
        =$}
        $=mentalState[=$lcount$=]=new TerImplication("=$rr$=",new BelSeq("=$rl$=",arr,bool));
        =$ } $=
        
        Agent agent=new Agent(mentalState,actuator,perceptor,modules,roleLib,res);
        PerceptionManager perManager=new PerceptionManager(agent,name,modules,services,scheduler);
        AffectManager affManager=new AffectManager(agent,name,modules,services,scheduler,roleLib);
        =$ perceptors{
        	$=perceptor[=$lcount$=]=new =$ classname $=(perManager);
        =$ } $=
        =$ actuators{
        	$=new =$classname$=(affManager).register(actuator);
        =$ } $=
         return new BasicRunnable(agent);
    } 

    =$ } 
    
    $=
    
    public String newStore(String s){
    	String identifier=null;
    	
		try {
			RecordStore rs = RecordStore.openRecordStore("=$ name $="+s, true);
			if (rs.getNumRecords() > 0)
				identifier = new String(rs.getRecord(1));
			rs.closeRecordStore();
		} catch (RecordStoreException rse) {
				rse.printStackTrace();
		}
		return identifier;
    }
    
    public void addData(String identifier,String s){

		try {
			ByteArrayOutputStream bout = new ByteArrayOutputStream();
			DataOutputStream dout = new DataOutputStream(bout);
			dout.writeUTF(identifier);
			byte[] data = bout.toByteArray();
			RecordStore rs = RecordStore.openRecordStore("=$ name $="+s, true);
			rs.addRecord(data, 0, data.length);
			bout.close();
			dout.close();
			rs.closeRecordStore();
		} catch (RecordStoreException rse) {
			rse.printStackTrace();
		}catch(IOException e){
			e.printStackTrace();
		}
    }
    
      public void saveID(String sb){
     
    			try {
    				ByteArrayOutputStream bout = new ByteArrayOutputStream();
    				DataOutputStream dout = new DataOutputStream(bout);
    				dout.writeUTF(sb.toString());
    				byte[] data = bout.toByteArray();
    				RecordStore rs = RecordStore.openRecordStore("=$ name $=IDS", true);
    				rs.addRecord(data, 0, data.length);
    				bout.close();
    				dout.close();
    				rs.closeRecordStore();
    			} catch (RecordStoreException rse) {
    				rse.printStackTrace();
    			}catch(IOException e){
    				e.printStackTrace();
    			}
     }
    
    public void addIDs(Object name,IDSet ident){
    	for(int i=ids.length;i-->0;){
    		int ind=ids[i].indexOf(' ');
    		String s=ids[i].substring(0,ind);
    		
    		String s2=ids[i].substring(ind+1);
    		int ind2=s2.indexOf(',');
    		if(s.equals(name))
    			ident.addID(new AID(FOS.createFOS(s2.substring(8,ind2)),
    			FOS.createFOS(s2.substring(ind2+1,s2.length()-1))));
    	}
    }
    
    public void storeName(FOS name){
    	try {
			
			RecordStore rs = RecordStore.openRecordStore("=$ name $=NameStore", true);
			java.io.ByteArrayOutputStream bout = null;
			java.io.DataOutputStream dout = null;
			try {

				bout = new java.io.ByteArrayOutputStream();
				dout = new java.io.DataOutputStream(bout);
				dout.writeUTF(name.toString());
				byte[] data = bout.toByteArray();

				rs.addRecord(data, 0, data.length);
				bout.close();
				dout.close();
			} catch (java.io.IOException e) {
				e.printStackTrace();
			}
			rs.closeRecordStore();

		} catch (RecordStoreException rse) {
			rse.printStackTrace();
		}
    }
    
    public void emigrate(AgentName name){
        StringBuffer buffer=new StringBuffer();
        name.appendName(buffer);
        String n=buffer.toString();
        
        agents.remove(n);
        
        
        scheduler.remove(name);
        Enumeration e=services.elements();
        while(e.hasMoreElements())
            ((Service)e.nextElement()).modifyBinding(name,null);
        
        
    }
    
    public void writeAgent(Object key,java.io.DataOutput dos)throws IOException{
    	scheduler.writeAgent(key,dos);
    }
    
    public void writeRes(Object key,java.io.DataOutput dos)throws IOException{
    	scheduler.writeOut(key,dos);
    }

	public void createAgent(DataInput dis) throws java.io.IOException {

		String nm = dis.readUTF();
		System.out.println("receiving: " + nm);
		AgentName name = new AgentName(nm, "=$ name $=");

		int numPerceptors = dis.readInt();

		Perceptor[] perceptors = new Perceptor[numPerceptors];
		Hashtable actuators = new Hashtable();
		Hashtable modules = new Hashtable();

		int resources = 0;

		//int nRole = dis.readInt();

		resources = dis.readInt();

		RoleLibrary roleLib = new RoleLibrary();
		TerImplication rules[] = createRules(dis);
		Agent agent = new Agent(rules, actuators, perceptors, modules, roleLib,
				resources);

		PerceptionManager perManager = new PerceptionManager(agent, name,
				modules, services, scheduler);
		try {

			for (int i = numPerceptors; i-- > 0;) {
				String string = dis.readUTF();
				Class p = Class.forName(string.substring(6) + "Fact");
				PerceptorFactory percep = (PerceptorFactory) p.newInstance();
				perceptors[i] = percep.createPerceptor(perManager);
			}

			AffectManager affManager = new AffectManager(agent, name, modules,
					services, scheduler, roleLib);

			for (int i = dis.readInt(); i-- > 0;) {
				String string = dis.readUTF();

				Class a = Class.forName(string.substring(6) + "Fact");
				ActuatorFactory actFact = (ActuatorFactory) a.newInstance();
				Actuator act = actFact.createActuator(affManager);
				act.register(actuators);
			}

			for (int i = dis.readInt(); i-- > 0;) {

				String string = dis.readUTF();
				Class a = Class.forName(string.substring(6) + "Fact");

				Object o = a.newInstance();

				if (o instanceof GUIFactory) {

					Module module = ((GUIFactory) o).createGUI(name, let, null);
					module.register(modules);
					inter = (UserInterface) module;
				} else {
					((ModuleFactory) o).createModule(name).register(modules);
				}

			}
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		for (int j = dis.readInt(); j-- > 0;) {
			try {
				String st = dis.readUTF();
				if(!st.startsWith("always(committed_to"))
				agent.addFOSBelief(FOS.createFOS(st));
			} catch (MalformedLogicException e) {
				e.printStackTrace();
			}
		}

		for (int j = dis.readInt(); j-- > 0;) {
			try {
				String st = dis.readUTF();
				
				agent.retractBelief(FOS.createFOS(st));
			} catch (MalformedLogicException e) {
				e.printStackTrace();
			}
		}

		StringBuffer buffer = new StringBuffer();
		name.appendName(buffer);
		String s = buffer.toString();

		
		BasicRunnable runnable = new BasicRunnable(agent);
		runnable.start();

		agents.put(s, runnable);
		Enumeration e = services.elements();

		while (e.hasMoreElements())
			((Service) e.nextElement()).modifyBinding(null, name);

		int numTemplates = dis.readInt();
		for (int i = numTemplates; i-- > 0;) {

			
			TerImplication[] rule = createRules(dis);
			int numTrig = dis.readInt();
			FOS[] trigger = new FOS[numTrig];
			for (int j = numTrig; j-- > 0;)
				trigger[j] = FOS.createFOS(dis.readUTF());
			FOS id = FOS.createFOS(dis.readUTF());
			roleLib.add(id, new RoleTemplate(rule, id, trigger));

		}
		scheduler.schedule(name, runnable, dis.readInt());

	}

	TerImplication[] createRules(DataInput dis) throws IOException {
		int numR = dis.readInt();
		TerImplication[] rule = new TerImplication[numR];
		for (int i = numR; i-- > 0;) {
			String s = dis.readUTF();

			int ind = s.indexOf('>') + 9;

			int n = s.length();
			boolean b = false;
			int k = n - 2;
			String val = "1";
			String cst = "0";
			String lab=null;
			int index = 0;
			while (k-- > 0) {

				if (s.charAt(k) == ',') {
					if (b) {
						val = s.substring(k + 1, index);
						break;
					} else {
						String str=s.substring(k + 1, n - 1);
						char c=str.charAt(0);
						
						
						if(c=='?'||(c-'0'>=0&&c-'0'<=9)){
							cst = str;
							b = true;
							index = k;
						}else{
							lab=str;
							n=k;
						}
					}
				}
			}
			String commit = s.substring(ind, k) + TerImplication.APOS + val
					+ ',' + cst;
			if(lab!=null)commit+=','+lab;
			commit+="4";

			String belSeq = s.substring(0, ind-9);

			StringBuffer sb = new StringBuffer();
			int n2 = belSeq.length();
			int num = 1;
			int br = 0;
			for (int j = 0; j < n2; j++) {
				char c = belSeq.charAt(j);
				if (c == ' ')
					continue;
				sb.append(c);
				if (c == '(')
					br++;
				else if (c == ')')
					br--;
				else if (c == ',' && br == 0)
					num++;
			}
			sb.append('|');
			sb.append(num);
			belSeq = sb.toString();
			rule[i] = new TerImplication(commit, new BelSeq(belSeq,
					new BelSeq[0], new boolean[0]));

		}

		return rule;
	}
	
}=$
