// Copyright:   Copyright (c) 1996-2006 The Agent Factory Working Group. All rights reserved.
// Licence:     This file is free software; you can redistribute it and/or modify
//              it under the terms of the GNU Lesser General Public License as published by
//              the Free Software Foundation; either version 2.1, or (at your option)
//              any later version.
//
//              This file is distributed in the hope that it will be useful,
//              but WITHOUT ANY WARRANTY; without even the implied warranty of
//              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//              GNU Lesser General Public License for more details.
//
//              You should have received a copy of the GNU Lesser General Public License
//              along with Agent Factory Micro Edition; see the file COPYING.  If not, write to
//              the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
//              Boston, MA 02111-1307, USA.
//
//				Author: Conor Muldoon

$=/*  =$name$=AgentPlatform.java  */

// Generated by the Agent Factory Micro Edition (AFME) compiler.

package =$ pack $=;
import com.agentfactory.cldc.logic.FOS;

import com.agentfactory.cldc.logic.RoleLibrary;
import com.agentfactory.cldc.logic.RoleTemplate;
import com.agentfactory.cldc.logic.BelSeq;
import com.agentfactory.cldc.BasicRunnable;
import java.util.Hashtable;
import com.agentfactory.cldc.AgentName;


import com.agentfactory.cldc.UserInterface;
import com.agentfactory.cldc.scheduler.AgentRunnable;

import com.agentfactory.cldc.PerceptionManager;
import com.agentfactory.cldc.AffectManager;
import com.agentfactory.cldc.Perceptor;
import com.agentfactory.cldc.scheduler.Scheduler;
import com.agentfactory.cldc.logic.TerImplication;
import com.agentfactory.cldc.logic.Agent; 
import com.agentfactory.cldc.Platform;
import com.agentfactory.cldc.Actuator;

import com.agentfactory.cldc.migration.MigrationPlatform;
import com.agentfactory.cldc.PerceptorFactory;
import com.agentfactory.cldc.ActuatorFactory;
import com.agentfactory.cldc.ModuleFactory;
import com.agentfactory.cldc.Module;

import java.util.Enumeration;
import com.agentfactory.cldc.Service;
import java.io.DataInput;
import java.io.File;
import java.io.RandomAccessFile;
import java.io.IOException;
import com.agentfactory.cldc.mts.IDSet;

public class =$ name $=AgentPlatform implements Platform,MigrationPlatform{
    
    
    
  
	public static void main(String[]args){
		new =$ name $=AgentPlatform(args);
	}
  
  	Hashtable services,agents;
  	Scheduler scheduler;

	public =$ name $=AgentPlatform(String[]a) {
		
		
    	=$  agents{ $=AgentRunnable =$ agtname $=;
    	AgentName =$ agtname $=Name;=$ } $=
    	

        
        scheduler=new Scheduler(=$ numt $=);
        
      
        services = new Hashtable();
        
        agents=new Hashtable();

       
       
       =$ agents{ 
       agtname $=Name=new AgentName("=$ agtname $=",null);
       =$ agtname $===$ namerole $=(=$ agtname $=Name,=$ resources $=,scheduler,services);
       =$ agtname $=Name.addToTable(agents,=$agtname$=); =$ } 
       $=
       

       =$  bels{
       believer $=.addFOSBelief(FOS.createFOS("=$ bel $="));
       =$ } $=
       
       =$  starters{
       agtname$=.start();=$ } $=
       
       //String[]stringNames=new String[=$ numagts $=];
       =$ agents{
       //agtname$=Name.addName(stringNames,=$lcount$=);
       //=$ 
       } $=
            
       

        final AgentName agentName[]=new AgentName[=$numagts$=];
        =$  agents{
        $=agentName[=$lcount$=]==$agtname$=Name;
        =$ } $=
        
       
        //Service service;
        String[] args;
        =$
         services{
    $=
    	args=new String[=$numargs$=];=$
  	args{
        		$=
        args[=$lcount$=]="=$arg$=";=$
        	}
$=
		new =$classname$=(args,agentName,scheduler,this).register(services);
        =$ }
         
         $=
        
       
     	
        =$  agents{
        	$=scheduler.schedule(=$agtname$=Name,=$agtname$=,=$responsetime$=);
        =$ } $=
		scheduler.start();
        
        int n=a.length;
		for(int i=0;i<n;i=i+2){
    	   =$  agents{$=
    	   if(a[i].equals("=$agtname$=")){
    	       =$agtname$=.addFOSBelief(FOS.createFOS(a[i+1]));
    	    	continue;
    	    }
        	=$ } $=
        }
         
    }
  

  
    
   
    
    =$designs{$=private static BasicRunnable =$namerole$=(AgentName name,int res,Scheduler scheduler,Hashtable services){
        
        Perceptor[]perceptor=new Perceptor[=$ numper $=];
        Hashtable actuator=new Hashtable();
        RoleLibrary roleLib=new RoleLibrary();
        BelSeq[] arr=null;
        
        boolean[] bool=null;
        =$  roles{
            $=TerImplication[]rule=new TerImplication[=$ numrules $=];
        =$  rules{$=
        		arr=new BelSeq[=$belNum$=];
        		bool=new boolean[=$belNum$=];
        		=$
        		depends{$=
        			arr[=$lcount$=]==$label$=;
        			bool[=$lcount$=]==$boolval$=;
        		=$
        		}
            	$=rule[=$lcount$=]=new TerImplication("=$rr$=",new BelSeq("=$rl$=",arr,bool));
        =$ } $=
        FOS[]trigger=new FOS[=$numtriggers$=];
        =$  triggers{
        	$=trigger[=$lcount$=]=FOS.createFOS("=$trig$=");
        =$ } $=
        FOS id=FOS.createFOS("=$id$=");
        roleLib.add(id,new RoleTemplate(rule,id,trigger));
        =$ } $=

        Hashtable modules=new Hashtable();
        
        
        =$ modules{
         	$=new =$ classname $=(name).register(modules);
         =$ } $=

        
		=$ sequences{ $=
        arr=new BelSeq[=$belNum$=];
        bool=new boolean[=$belNum$=];
        =$ depends{$=
        arr[=$lcount$=]==$label$=;
        bool[=$lcount$=]==$boolval$=;
        =$}
        $=BelSeq =$ label $==new BelSeq("=$rl$=",arr,bool);
        =$ } $=
        
        TerImplication[]mentalState=new TerImplication[=$ numrules $=];
        =$  rules{$=arr=new BelSeq[=$belNum$=];
        bool=new boolean[=$belNum$=];
        =$depends{$=
        arr[=$lcount$=]==$label$=;
        bool[=$lcount$=]==$boolval$=;
        =$}
        $=mentalState[=$lcount$=]=new TerImplication("=$rr$=",new BelSeq("=$rl$=",arr,bool));
        =$ } $=
        
        Agent agent=new Agent(mentalState,actuator,perceptor,modules,roleLib,res);
        PerceptionManager perManager=new PerceptionManager(agent,name,modules,services,scheduler);
        AffectManager affManager=new AffectManager(agent,name,modules,services,scheduler,roleLib);
        =$ perceptors{
        	$=perceptor[=$lcount$=]=new =$ classname $=(perManager);
        =$ } $=
        =$ actuators{
        	$=new =$classname$=(affManager).register(actuator);
        =$ } $=
         return new BasicRunnable(agent);
    } 

    =$ } 
    
    $=
    public void display(){
    
    }
    
     public void saveID(String sb){
     
     }
    
    public void addIDs(Object name,IDSet ids){
    
    }
    
    
    public String newStore(String s){
    	String identifier=null;
    	
		try {
			File f=new File("=$ name $="+s+".afme");
			if(f.exists()){
				RandomAccessFile raf = new RandomAccessFile(f, "rw");
				identifier=raf.readUTF();
				raf.close();
			}
			else f.createNewFile();
		} catch (IOException e) {
				e.printStackTrace();
		}
		return identifier;
    }
    
    public void addData(String identifier,String s){
    	try {
			File f=new File("=$ name $="+s+".afme");
			RandomAccessFile raf = new RandomAccessFile(f, "rw");
			raf.seek(f.length());
			raf.writeUTF(identifier);
			raf.close();
			
		} catch(IOException e){
			e.printStackTrace();
		}
    }
    
    public void storeName(FOS name){
    	try {
			
			File f=new File("=$ name $=NameStore.afme");
			if(!f.exists())f.createNewFile();
			RandomAccessFile raf = new RandomAccessFile(f, "rw");
			raf.seek(f.length());
			raf.writeUTF(name.toString());
			
		} catch (IOException e) {
			e.printStackTrace();
		}
    
    }
    
    public void emigrate(AgentName name){
        StringBuffer buffer=new StringBuffer();
        name.appendName(buffer);
        String n=buffer.toString();
        
        agents.remove(n);
        
        scheduler.remove(name);
        Enumeration e=services.elements();
        while(e.hasMoreElements())
            ((Service)e.nextElement()).modifyBinding(name,null);
        
        
    }
    
    public void writeAgent(Object key,java.io.DataOutput dos)throws IOException{
    	scheduler.writeAgent(key,dos);
    }
    
    public void writeRes(Object key,java.io.DataOutput dos)throws IOException{
    	scheduler.writeOut(key,dos);
    }

	public void createAgent(DataInput dis) throws java.io.IOException {

		String nm = dis.readUTF();
		System.out.println("receiving: " + nm);
		AgentName name = new AgentName(nm, "=$ name $=");

		int numPerceptors = dis.readInt();

		Perceptor[] perceptors = new Perceptor[numPerceptors];
		Hashtable actuators = new Hashtable();
		Hashtable modules = new Hashtable();

		int resources = 0;

		//int nRole = dis.readInt();

		resources = dis.readInt();

		RoleLibrary roleLib = new RoleLibrary();
		TerImplication rules[] = createRules(dis);
		Agent agent = new Agent(rules, actuators, perceptors, modules, roleLib,
				resources);

		PerceptionManager perManager = new PerceptionManager(agent, name,
				modules, services, scheduler);
		try {

			for (int i = numPerceptors; i-- > 0;) {
				String string = dis.readUTF();
				Class p = Class.forName(string.substring(6) + "Fact");
				PerceptorFactory percep = (PerceptorFactory) p.newInstance();
				perceptors[i] = percep.createPerceptor(perManager);
			}

			AffectManager affManager = new AffectManager(agent, name, modules,
					services, scheduler, roleLib);

			for (int i = dis.readInt(); i-- > 0;) {
				String string = dis.readUTF();

				Class a = Class.forName(string.substring(6) + "Fact");
				ActuatorFactory actFact = (ActuatorFactory) a.newInstance();
				Actuator act = actFact.createActuator(affManager);
				act.register(actuators);
			}

			for (int i = dis.readInt(); i-- > 0;) {

				String string = dis.readUTF();
				Class a = Class.forName(string.substring(6) + "Fact");

				((ModuleFactory) a.newInstance()).createModule(name).register(modules);


			}
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}

		for (int j = dis.readInt(); j-- > 0;) {
			
			String st = dis.readUTF();
			if(!st.startsWith("always(committed_to"))	
			agent.addFOSBelief(FOS.createFOS(st));
			
		}

		for (int j = dis.readInt(); j-- > 0;) {
			
			String st = dis.readUTF();
			
			agent.retractBelief(FOS.createFOS(st));
			
		}

		StringBuffer buffer = new StringBuffer();
		name.appendName(buffer);
		String s = buffer.toString();

		BasicRunnable runnable = new BasicRunnable(agent);
		runnable.start();

		agents.put(s, runnable);
		Enumeration e = services.elements();

		while (e.hasMoreElements())
			((Service) e.nextElement()).modifyBinding(null, name);

		int numTemplates = dis.readInt();
		for (int i = numTemplates; i-- > 0;) {

			
			TerImplication[] rule = createRules(dis);
			int numTrig = dis.readInt();
			FOS[] trigger = new FOS[numTrig];
			for (int j = numTrig; j-- > 0;)
				trigger[j] = FOS.createFOS(dis.readUTF());
			FOS id = FOS.createFOS(dis.readUTF());
			roleLib.add(id, new RoleTemplate(rule, id, trigger));

		}
		scheduler.schedule(name, runnable, dis.readInt());

	}

	TerImplication[] createRules(DataInput dis) throws IOException {
		int numR = dis.readInt();
		TerImplication[] rule = new TerImplication[numR];
		for (int i = numR; i-- > 0;) {
			String s = dis.readUTF();

			int ind = s.indexOf('>') + 9;

			int n = s.length();
			boolean b = false;
			int k = n - 2;
			String val = "1";
			String cst = "0";
			String lab=null;
			int index = 0;
			while (k-- > 0) {

				if (s.charAt(k) == ',') {
					if (b) {
						val = s.substring(k + 1, index);
						break;
					} else {
						String str=s.substring(k + 1, n - 1);
						char c=str.charAt(0);
						
						
						if(c=='?'||(c-'0'>=0&&c-'0'<=9)){
							cst = str;
							b = true;
							index = k;
						}else{
							lab=str;
							n=k;
						}
					}
				}
			}
			String commit = s.substring(ind, k) + TerImplication.APOS + val
					+ ',' + cst;
			if(lab!=null)commit+=','+lab;
			commit+="4";

			String belSeq = s.substring(0, ind-9);

			StringBuffer sb = new StringBuffer();
			int n2 = belSeq.length();
			int num = 1;
			int br = 0;
			for (int j = 0; j < n2; j++) {
				char c = belSeq.charAt(j);
				if (c == ' ')
					continue;
				sb.append(c);
				if (c == '(')
					br++;
				else if (c == ')')
					br--;
				else if (c == ',' && br == 0)
					num++;
			}
			sb.append('|');
			sb.append(num);
			belSeq = sb.toString();
			rule[i] = new TerImplication(commit, new BelSeq(belSeq,
					new BelSeq[0], new boolean[0]));

		}

		return rule;
	}

}=$
